<details>
<summary>ç‚¹å‡»å±•å¼€ç›®å½•</summary>
<!-- TOC -->

- [ReentrantLock](#reentrantlock)
    - [æ–¹æ³•](#æ–¹æ³•)
    - [Usage](#usage)
    - [å®ç°åŸç†](#å®ç°åŸç†)

<!-- /TOC -->
</details>

## ReentrantLock

* å¯é‡å…¥çš„äº’æ–¥é”(æ’å®ƒé”)
* åˆ†ä¸ºå…¬å¹³é”å’Œéå…¬å¹³é”, é»˜è®¤ä¸ºéå…¬å¹³, åŒºåˆ«åœ¨äºé”çš„è·å–æ˜¯å¦æŒ‰ç…§FIFOçš„é¡ºåº, ä½†å…¬å¹³é”æ€§èƒ½æœ‰æ‰€æ¬ ç¼º
* é€šè¿‡FIFOé˜Ÿåˆ—ç®¡ç†è·å–è¯¥é”ğŸ”æ‰€æœ‰çº¿ç¨‹çš„

å¯é‡å…¥:

åŒæ­¥é”ä¹Ÿæ˜¯å¯é‡å…¥çš„, å…·ä½“çš„ä¸€ä¸ªåœºæ™¯å°±æ˜¯åœ¨ä¸€ä¸ªåŒæ­¥åŸŸå†…è°ƒç”¨æœ¬ç±»çš„å…¶ä»–ç”±`synchronized`ä¿®é¥°çš„æ–¹æ³•æˆ–ä»£ç å—æ—¶,æ˜¯æ°¸è¿œå¯ä»¥å¾—åˆ°é”çš„

ä¼˜ç‚¹æ˜¯èƒ½å¤Ÿé¿å…æ­»é”: çº¿ç¨‹è·å¾—æŸå¯¹è±¡çš„é”å, æœªé‡Šæ”¾çŠ¶æ€ä¸‹å†æ¬¡è·å–è¯¥å¯¹è±¡çš„é”æ—¶, å¦‚æœä¸æ”¯æŒé‡å…¥, å°±ä¼šé€ æˆæ­»é”.

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/ReentrantLock.jpg)

### æ–¹æ³•

| æ–¹æ³•                                        | è¯´æ˜                                                 |
| ------------------------------------------- | ---------------------------------------------------- |
| `ReentrantLock(boolean fair)`               | æœ‰å‚æ„é€ , true:å…¬å¹³é”                                |
| `void lock()`                               | è·å–é”                                               |
| `boolean tryLock()`                         | å°è¯•éé˜»å¡å¼è·å–é”(æ–¹æ³•æ‰§è¡Œåç«‹å³è¿”å›)               |
| `boolean tryLock(long time, TimeUnit unit)` | è¶…æ—¶æ—¶é—´å†…è·å–é”,è·å–è¿‡ç¨‹ä¸­è¢«ä¸­æ–­,è¶…æ—¶ä¸‰ç§æƒ…å†µä¸‹è¿”å› |
| `void lockInterruptibly()`                  | è·å–é”çš„è¿‡ç¨‹ä¸­å¯ä»¥ä¸­æ–­å½“å‰çº¿ç¨‹                       |
| `void unlock()`                             | é‡Šæ”¾é”                                               |
| `Condition newCondition()`                  | è·å–ç­‰å¾…é€šçŸ¥ç»„ä»¶,çº¿ç¨‹é—´é€šä¿¡ç”¨                        |

### Usage

```Java
public static void main(String[] args) {
    Lock lock = new ReentrantLock();
    // Condition condition = lock.newCondition();// åˆ›å»ºCondition,å¯ä»¥å­˜åœ¨å¤šä¸ª
    new Thread(() -> doSome(lock), "thread1").start();
    new Thread(() -> doSome(lock), "thread2").start();
}
private static void doSome(Lock lock) {
    try {lock.lock();}
    ......;
    finally{lock.unlock();}
}
```

### å®ç°åŸç†

```Java
private final Sync sync;
static abstract class Sync extends AbstractQueuedSynchronizer{}
final static class NonfairSync extends Sync{}
final static class FairSync extends Sync{}
```

**åŠ é”**

```Java
// éå…¬å¹³é”
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else // ç›´æ¥ä½¿ç”¨aqsçš„æ–¹æ³•
        acquire(1);
}
// å…¬å¹³é”
final void lock() {
    acquire(1);
}
```

å¯ä»¥çœ‹åˆ°å…³é”®éƒ¨åˆ†éƒ½åœ¨`acquire`æ–¹æ³•, å…¶å†…éƒ¨è°ƒç”¨`tryAcquire`æ–¹æ³•, è¯¥æ–¹æ³•éœ€è¦aqså®ç°ç±»æ¥å®ç°:

éå…¬å¹³é”çš„å®ç°:
```Java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);// Syncç±»ä¸­å®ç°
}
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {// é”æœªè¢«è·å–
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if (current == getExclusiveOwnerThread()) {// ç‹¬å é”æŒæœ‰çº¿ç¨‹æ˜¯å¦æ˜¯å½“å‰çº¿ç¨‹
        int nextc = c + acquires;// é‡å…¥æ¬¡æ•°
        if (nextc < 0) // overflow:é‡å…¥æ¬¡æ•°è¶…å‡º
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

å…¬å¹³é”çš„`tryAcquire`çš„å®ç°å’Œéå…¬å¹³çš„åªæœ‰ä¸€ç‚¹ä¸åŒ, å°±æ˜¯`state=0`å†…çš„åˆ¤æ–­æ¡ä»¶å¤šäº†ä¸€ä¸ªä¸æ¡ä»¶`!hasQueuedPredecessors()`
å³`æ˜¯å¦æœ‰æ’é˜Ÿçš„å‰é©±èŠ‚ç‚¹`

```Java
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```
æ­¤æ–¹æ³•çš„ä½œç”¨æ˜¯: `Queries whether any threads have been waiting to acquire longer than the current thread.`
åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ¯”å½“å‰çº¿ç¨‹ç­‰å¾…æ›´ä¹…çš„çº¿ç¨‹, å³åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºCLHé˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ª

`true if there is a queued thread preceding the current thread, and false if the current thread is at the head of the queue or the queue is empty`
å¦‚æœå½“å‰çº¿ç¨‹å‰æœ‰æ’é˜Ÿçš„çº¿ç¨‹, è¿”å›true, å¦‚æœå½“å‰çº¿ç¨‹åœ¨é˜Ÿå¤´æˆ–é˜Ÿåˆ—ä¸ºç©º, è¿”å›false

**é‡Šæ”¾é”**

```Java
public void unlock() {
    sync.release(1);
}
```
å…¶å†…éƒ¨ç›´æ¥ä½¿ç”¨`tryRelease`æ–¹æ³•, ç±»ä¼¼çš„, æ­¤æ–¹æ³•ä¹Ÿéœ€è¦å®ç°ç±»è¿›è¡Œå…·ä½“å®ç°:
```Java
protected final boolean tryRelease(int releases) {
    // å‡å°‘é‡å…¥æ¬¡æ•°
    int c = getState() - releases;
    // å½“å‰é‡Šæ”¾é”çš„çº¿ç¨‹ä¸æ˜¯æŒæœ‰è¯¥é”çš„çº¿ç¨‹ -> å¼‚å¸¸
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {// å·²ç»æ²¡æœ‰çº¿ç¨‹æŒæœ‰è¯¥é”
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
