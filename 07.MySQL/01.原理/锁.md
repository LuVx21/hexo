锁类型：行锁、表锁
锁模式：读锁、写锁、自增锁、读意向锁、写意向锁
自增锁（AI锁）：自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。


## record 锁

## 间隙锁

间隙锁：能否插入整个锁的前后两个边界值，取决于聚簇索引
间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入。

唯一索引不会有间隙锁，除非是由于二级索引上的gap锁引起的聚簇索引加gap锁

next-key



插入意向锁:和插入意向锁之间互不冲突（行级锁）和上面的表级别的写意向锁不同。
插入意向锁又叫（II GAP）Insert Intention GAP，也是一种 GAP 锁

> 插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行

（不走索引的加锁流程）注意：如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。
如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由 MySQL Server 层进行过滤。
不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁（显然这违背了两段锁协议）。
这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。
可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。
