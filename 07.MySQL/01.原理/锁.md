<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [record 锁](#record-锁)
- [间隙锁](#间隙锁)

<!-- /TOC -->
</details>

锁类型: 行锁, 表锁
锁模式: 读锁, 写锁, 自增锁, 读意向锁, 写意向锁
自增锁(AI锁): 自增值一旦分配了就会 +1, 如果事务回滚, 自增值也不会减回去, 所以自增值可能会出现中断的情况.

## record 锁

## 间隙锁

间隙锁: 能否插入整个锁的前后两个边界值, 取决于聚簇索引
间隙锁和间隙锁之间是互不冲突的, 间隙锁唯一的作用就是为了防止其他事务的插入.

唯一索引不会有间隙锁, 除非是由于二级索引上的gap锁引起的聚簇索引加gap锁

next-key



插入意向锁: 和插入意向锁之间互不冲突(行级锁)和上面的表级别的写意向锁不同.
插入意向锁又叫(II GAP)Insert Intention GAP, 也是一种 GAP 锁

> 插入意向锁只会和间隙锁或 Next-key 锁冲突, 正如上面所说, 间隙锁唯一的作用就是防止其他事务插入记录造成幻读, 那么间隙锁是如何防止幻读的呢? 正是由于在执行 INSERT 语句时需要加插入意向锁, 而插入意向锁和间隙锁冲突, 从而阻止了插入操作的执行

(不走索引的加锁流程)注意: 如果 SQL 语句无法使用索引时会走主索引实现全表扫描, 这个时候 MySQL 会给整张表的所有数据行加记录锁.
如果一个 WHERE 条件无法通过索引快速过滤, 存储引擎层面就会将所有记录加锁后返回, 再由 MySQL Server 层进行过滤.
不过在实际使用过程中, MySQL 做了一些改进, 在 MySQL Server 层进行过滤的时候, 如果发现不满足, 会调用 unlock_row 方法, 把不满足条件的记录释放锁(显然这违背了两段锁协议).
这样做, 保证了最后只会持有满足条件记录上的锁, 但是每条记录的加锁操作还是不能省略的.
可见在没有索引时, 不仅会消耗大量的锁资源, 增加数据库的开销, 而且极大的降低了数据库的并发性能, 所以说, 更新操作一定要记得走索引.
